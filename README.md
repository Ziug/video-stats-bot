# Telegram-бот для аналитики видео

Проект представляет собой Telegram-бота, который принимает текстовые запросы на русском языке и возвращает *числовые* результаты, полученные из базы данных PostgreSQL.\
Запросы пользователя преобразуются в SQL с помощью LLM.

Запуск проекта 
---
Установка зависимостей

`python -m venv .venv` \
`source .venv/bin/activate` если на МакБуке/линуксе **/** `.\venv\Scripts\activate.bat` если на windows \
`pip install -r requirements.txt`

### Переменные окружения 
задаются токены для бота телеграм/мистраль + конфигурация БД

DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/dbname \
TELEGRAM_BOT_TOKEN=токен-бота-телеграма \
MISTRAL_API_KEY=апи-мистраля

Запуск
---
`python src/bot.py`


Настройка токена Telegram-бота
---
Токен Telegram-бота передаётся через переменную окружения:
TELEGRAM_BOT_TOKEN=токен-бота-телеграма


Архитектура работы бота
---

Общая схема работы
1.	Пользователь отправляет текстовый запрос в Telegram
2.	Бот передаёт текст запроса в LLM
3.	LLM возвращает SQL-запрос
4.	Бот валидирует SQL
5.	SQL выполняется в PostgreSQL
6.	Пользователь получает числовой результат

### Преобразование текстовых запросов в SQL

Преобразование выполняется с использованием LLM (Mistral AI).\
LLM используется только для генерации SQL-запроса, выполнение и проверка запроса реализованы в коде приложения.

Перед выполнением SQL проходит валидацию:
- допускается только SELECT;
- запрещены операции, которые манипулируют данными в БД;
- запрос должен возвращать одно числовое значение.


Использование LLM
---

Схема данных передаётся в промпт в данном виде:
- перечисляются доступные таблицы;
- указываются поля и их назначение;
- описываются допустимые связи.

LLM не делает предположений о структуре базы данных и работает только в рамках переданного описания.


Промпт
---
```
Ты помощник по генерации SQL запросов для аналитики видео.

Таблица videos содержит итоговую статистику по каждому видео:
- id: идентификатор видео
- creator_id: идентификатор креатора
- video_created_at: дата и время публикации видео
- views_count: финальное количество просмотров
- likes_count: финальное количество лайков
- comments_count: финальное количество комментариев
- reports_count: финальное количество жалоб
- created_at: дата создания записи
- updated_at: дата обновления записи

Таблица video_snapshots содержит почасовые снапшоты статистики:
- id: идентификатор снапшота
- video_id: ссылка на видео
- views_count: количество просмотров на момент замера
- likes_count: количество лайков на момент замера
- comments_count: количество комментариев на момент замера
- reports_count: количество жалоб на момент замера
- delta_views_count: прирост просмотров с предыдущего снапшота
- delta_likes_count: прирост лайков с предыдущего снапшота
- delta_comments_count: прирост комментариев с предыдущего снапшота
- delta_reports_count: прирост жалоб с предыдущего снапшота
- created_at: время снапшота (раз в час)
- updated_at: дата обновления

ВАЖНО: Ответ ДОЛЖЕН быть JSON {"sql": "<SQL>"} и SQL ДОЛЖЕН ВОЗВРАЩАТЬ ОДНО ЧИСЛО!

Примеры запросов и ответов:
"Сколько всего видео?" -> {"sql": "SELECT COUNT(*) FROM videos"}
"Сколько видео у креатора abc?" -> {"sql": "SELECT COUNT(*) FROM videos WHERE creator_id = 'abc'"}
"Сколько видео с более чем 100000 просмотров?" -> {"sql": "SELECT COUNT(*) FROM videos WHERE views_count > 100000"}
"На сколько выросли просмотры 28 ноября?" -> {"sql": "SELECT COALESCE(SUM(delta_views_count),0) FROM video_snapshots WHERE date(created_at) = '2025-11-28'"}
"Сколько уникальных видео получали просмотры 27 ноября?" -> {"sql": "SELECT COUNT(DISTINCT video_id) FROM video_snapshots WHERE delta_views_count > 0 AND date(created_at) = '2025-11-27'"}

Правила:
1. SQL ДОЛЖЕН ВОЗВРАЩАТЬ РОВНО ОДНО ЧИСЛО
2. Используй COUNT, SUM, MAX, MIN, AVG для получения чисел
3. Никогда не возвращай названия, ID или текст - только числовые агрегаты
4. Возвращай ТОЛЬКО JSON {"sql": "..."}
5. Используй ТОЛЬКО таблицы videos и video_snapshots
6. Допускаются функции: COUNT, SUM, AVG, MIN, MAX, DISTINCT, date, COALESCE
7. Без точек с запятой в конце SQL
```

Промпт зафиксирован в коде и не формируется динамически.